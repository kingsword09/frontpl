export function editorconfigTemplate() {
  return [
    "root = true",
    "",
    "[*]",
    "charset = utf-8",
    "end_of_line = lf",
    "indent_style = space",
    "indent_size = 2",
    "insert_final_newline = true",
    "trim_trailing_whitespace = true",
    "",
    "[*.md]",
    "trim_trailing_whitespace = false",
    "",
  ].join("\n");
}

export function gitignoreTemplate() {
  return ["node_modules", "dist", "coverage", "*.log", ".DS_Store", ".env", ".env.*", ""].join(
    "\n",
  );
}

export function gitattributesTemplate() {
  return ["* text=auto eol=lf", ""].join("\n");
}

export function tsconfigTemplate() {
  return (
    JSON.stringify(
      {
        compilerOptions: {
          target: "ES2022",
          module: "ESNext",
          moduleResolution: "Bundler",
          strict: true,
          skipLibCheck: true,
          noEmit: true,
        },
        include: ["src"],
      },
      null,
      2,
    ) + "\n"
  );
}

export function srcIndexTemplate() {
  return ["export function hello(name: string) {", "  return `Hello, ${name}`;", "}", ""].join(
    "\n",
  );
}

export function srcVitestTemplate() {
  return [
    'import { describe, expect, it } from "vitest";',
    'import { hello } from "./index.js";',
    "",
    'describe("hello", () => {',
    '  it("greets", () => {',
    '    expect(hello("world")).toBe("Hello, world");',
    "  });",
    "});",
    "",
  ].join("\n");
}

export function readmeTemplate(projectName: string) {
  return [`# ${projectName}`, "", "Generated by `frontpl`.", ""].join("\n");
}

export function oxlintConfigTemplate({ useVitest }: { useVitest: boolean }) {
  void useVitest;
  return (
    JSON.stringify(
      {
        $schema: "https://json.schemastore.org/oxlintrc.json",
        env: {
          browser: true,
          es2022: true,
        },
      },
      null,
      2,
    ) + "\n"
  );
}

export function oxfmtConfigTemplate() {
  return (
    JSON.stringify(
      {
        $schema: "https://json.schemastore.org/oxfmtrc.json",
      },
      null,
      2,
    ) + "\n"
  );
}

export function tsdownConfigTemplate() {
  return [
    'import { defineConfig } from "tsdown";',
    "",
    "export default defineConfig({",
    '  entry: ["src/index.ts"],',
    '  platform: "browser"',
    "});",
    "",
  ].join("\n");
}

export function packageJsonTemplate(opts: {
  name: string;
  packageManager: string;
  typescriptVersion: string;
  useOxlint: boolean;
  oxlintVersion?: string;
  oxlintTsgolintVersion?: string;
  useOxfmt: boolean;
  oxfmtVersion?: string;
  useVitest: boolean;
  vitestVersion?: string;
  useTsdown: boolean;
  tsdownVersion?: string;
}) {
  const scripts: Record<string, string> = {
    typecheck: "tsc --noEmit",
  };

  if (opts.useOxlint) {
    const oxlintCmd = [
      "oxlint",
      opts.useVitest ? "--vitest-plugin" : undefined,
      "--type-aware",
      "--type-check",
    ]
      .filter(Boolean)
      .join(" ");
    scripts.lint = oxlintCmd;
    scripts["lint:fix"] = `${oxlintCmd} --fix`;
  }

  if (opts.useOxfmt) {
    scripts.format = "oxfmt";
    scripts["format:check"] = "oxfmt --check";
    scripts.fmt = "oxfmt";
    scripts["fmt:check"] = "oxfmt --check";
  }

  if (opts.useVitest) {
    scripts.test = "vitest";
  }

  if (opts.useTsdown) {
    scripts.build = "tsdown";
  }

  const devDependencies: Record<string, string> = {
    typescript: opts.typescriptVersion,
  };

  if (opts.useOxlint) {
    if (opts.oxlintVersion) devDependencies.oxlint = opts.oxlintVersion;
    if (opts.oxlintTsgolintVersion) devDependencies["oxlint-tsgolint"] = opts.oxlintTsgolintVersion;
  }

  if (opts.useOxfmt && opts.oxfmtVersion) devDependencies.oxfmt = opts.oxfmtVersion;
  if (opts.useVitest && opts.vitestVersion) devDependencies.vitest = opts.vitestVersion;
  if (opts.useTsdown && opts.tsdownVersion) devDependencies.tsdown = opts.tsdownVersion;

  return (
    JSON.stringify(
      {
        name: opts.name,
        version: "0.0.0",
        private: true,
        type: "module",
        scripts,
        devDependencies,
        packageManager: opts.packageManager,
      },
      null,
      2,
    ) + "\n"
  );
}

export function githubCliCiWorkflowTemplate(opts: {
  packageManager: "npm" | "pnpm" | "yarn" | "bun" | "deno";
  nodeVersion: number;
  workingDirectory: string;
  runLint: boolean;
  runFormatCheck: boolean;
  runTests: boolean;
  installCommand?: string;
  lintCommand?: string;
  formatCheckCommand?: string;
  testCommand?: string;
  workflowsRef?: string;
}) {
  const ref = opts.workflowsRef ?? "v1";
  const installCommand = opts.installCommand?.trim();
  const lintCommand = opts.lintCommand?.trim();
  const formatCheckCommand = opts.formatCheckCommand?.trim();
  const testCommand = opts.testCommand?.trim();
  return [
    "name: CI",
    "",
    "on:",
    "  push:",
    "    branches: [main]",
    "  pull_request:",
    "    branches: [main]",
    "",
    "jobs:",
    "  ci:",
    `    uses: kingsword09/workflows/.github/workflows/cli-ci.yml@${ref}`,
    "    with:",
    `      packageManager: ${opts.packageManager}`,
    `      nodeVersion: ${opts.nodeVersion}`,
    `      workingDirectory: ${opts.workingDirectory}`,
    `      runLint: ${opts.runLint}`,
    `      runFormatCheck: ${opts.runFormatCheck}`,
    `      runTests: ${opts.runTests}`,
    ...(installCommand ? [`      installCommand: ${yamlString(installCommand)}`] : []),
    ...(lintCommand ? [`      lintCommand: ${yamlString(lintCommand)}`] : []),
    ...(formatCheckCommand ? [`      formatCheckCommand: ${yamlString(formatCheckCommand)}`] : []),
    ...(testCommand ? [`      testCommand: ${yamlString(testCommand)}`] : []),
    "",
  ].join("\n");
}

export function githubCliReleaseWorkflowTemplate(opts: {
  packageManager: "npm" | "pnpm" | "yarn" | "bun" | "deno";
  nodeVersion: number;
  workingDirectory: string;
  trustedPublishing?: boolean;
  workflowsRef?: string;
}) {
  const ref = opts.workflowsRef ?? "v1";
  const trustedPublishing = opts.trustedPublishing;
  const needsNpmToken = opts.packageManager !== "deno" && trustedPublishing === false;
  return [
    "name: Release",
    "",
    "on:",
    "  push:",
    "    branches: [main]",
    "",
    "jobs:",
    "  release:",
    "    permissions:",
    "      contents: write",
    "      id-token: write",
    `    uses: kingsword09/workflows/.github/workflows/cli-release.yml@${ref}`,
    "    with:",
    `      packageManager: ${opts.packageManager}`,
    `      nodeVersion: ${opts.nodeVersion}`,
    `      workingDirectory: ${opts.workingDirectory}`,
    ...(trustedPublishing === undefined ? [] : [`      trustedPublishing: ${trustedPublishing}`]),
    ...(needsNpmToken ? ["    secrets:", "      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}"] : []),
    "",
  ].join("\n");
}

export function githubCliReleaseTagWorkflowTemplate(opts: {
  packageManager: "npm" | "pnpm" | "yarn" | "bun" | "deno";
  nodeVersion: number;
  workingDirectory: string;
  trustedPublishing?: boolean;
  workflowsRef?: string;
}) {
  const ref = opts.workflowsRef ?? "v1";
  const trustedPublishing = opts.trustedPublishing;
  const needsNpmToken = opts.packageManager !== "deno" && trustedPublishing === false;
  return [
    "name: Release",
    "",
    "on:",
    "  push:",
    "    tags: [v*.*.*]",
    "",
    "jobs:",
    "  release:",
    "    permissions:",
    "      contents: write",
    "      id-token: write",
    `    uses: kingsword09/workflows/.github/workflows/cli-release-tag.yml@${ref}`,
    "    with:",
    `      packageManager: ${opts.packageManager}`,
    `      nodeVersion: ${opts.nodeVersion}`,
    `      workingDirectory: ${opts.workingDirectory}`,
    ...(trustedPublishing === undefined ? [] : [`      trustedPublishing: ${trustedPublishing}`]),
    ...(needsNpmToken ? ["    secrets:", "      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}"] : []),
    "",
  ].join("\n");
}

export function githubCliReleaseBothWorkflowTemplate(opts: {
  packageManager: "npm" | "pnpm" | "yarn" | "bun" | "deno";
  nodeVersion: number;
  workingDirectory: string;
  trustedPublishing?: boolean;
  workflowsRef?: string;
}) {
  const ref = opts.workflowsRef ?? "v1";
  const trustedPublishing = opts.trustedPublishing;
  const needsNpmToken = opts.packageManager !== "deno" && trustedPublishing === false;
  return [
    "name: Release",
    "",
    "on:",
    "  push:",
    "    branches: [main]",
    "    tags: [v*.*.*]",
    "",
    "jobs:",
    "  release_tag:",
    "    if: startsWith(github.ref, 'refs/tags/')",
    "    permissions:",
    "      contents: write",
    "      id-token: write",
    `    uses: kingsword09/workflows/.github/workflows/cli-release-tag.yml@${ref}`,
    "    with:",
    `      packageManager: ${opts.packageManager}`,
    `      nodeVersion: ${opts.nodeVersion}`,
    `      workingDirectory: ${opts.workingDirectory}`,
    ...(trustedPublishing === undefined ? [] : [`      trustedPublishing: ${trustedPublishing}`]),
    ...(needsNpmToken ? ["    secrets:", "      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}"] : []),
    "",
    "  release_commit:",
    "    if: startsWith(github.ref, 'refs/heads/')",
    "    permissions:",
    "      contents: write",
    "      id-token: write",
    `    uses: kingsword09/workflows/.github/workflows/cli-release.yml@${ref}`,
    "    with:",
    `      packageManager: ${opts.packageManager}`,
    `      nodeVersion: ${opts.nodeVersion}`,
    `      workingDirectory: ${opts.workingDirectory}`,
    ...(trustedPublishing === undefined ? [] : [`      trustedPublishing: ${trustedPublishing}`]),
    ...(needsNpmToken ? ["    secrets:", "      NPM_TOKEN: ${{ secrets.NPM_TOKEN }}"] : []),
    "",
  ].join("\n");
}

function yamlString(value: string) {
  return JSON.stringify(value);
}
